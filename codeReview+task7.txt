1. line 109: for epoch in epochs
По (1.1.6) лучше избегать отличия одним окончанием -s, переделал: epochs -> epochArray

2. line 19-25: В классе Walker коментарии теперь с большой буквы (3.3.4)

3. line 19-25: В классе Walker очень не хвататет размерностей переменных. В ф-ии getInitialElements, однако, видно, что 
изначально они хранятся в градусах, но это надо пометить по (3.4.9)

Без ссылок на гайдлайн:

1. group, объявленный в 15 строке изначального кода нигде не используется, удалил.
2. В текущем исполнении класс Parameters избыточен, ведь мы навряд ли будем по ходу расширения класса
добавлять в него константы в отдельных частях программы, скорее константы будут добавлятся вручную в общий пул, 
тогда можно вынести их все в отдельный .py файл, или даже .txt файл.
3. Названия всех функций говорят сами за себя о том, что делает функция, но, возможно, 
имеет смысл это дополниетльно пояснить в комментарии наподобии того, что используется в Sphinx.

_________________________________________________________________________________________________________________________________________
Задание 7.

Предложите вычислительную процедуру построения матрицы связности для межспутниковой передачи данных (элемент ij имеет значение true, 
если связь между КА с номерами i и j есть, false - если нет). 
Постройте матрицу для одного эшелона (высота 720 км) группировки, которая создаётся в примере. 
Рассмотрите два случая: 
а) межспутниковая связь у каждого КА может быть с двумя соседними КА в той же орбитальной плоскости; 
б) то же, что в предыдущем случае, плюс у каждого КА может быть одна связь с соседней плоскостью. 
В последнем случае реализуйте процедуру поиска кратчайшего пути (минимум узлов) между двумя произвольно выбранными КА.

Перед решением задачи я изучил что делает каждая функция. 

Я решил взять для начала модель, которая предполагает наличия сеанса связи между двумя спутниками,
если расстояние между ними меньше определенной дистанции.

Поскольку пропагатор создает массив stateEci, можно 
воспользоваться им для того чтобы рассчитать расстояние между спутниками в каждый момент времени.

Однако считать по каждому отрезку было бы затратно, и я решил взять каждую десятую отсечку.

Далее для того чтобы определять находятся ли два КА в одной орбитальной плоскости я делил их индексы внутри
группы (который предварительно высчитал, вычев "сдвиг", полученный из подсчета кол-ва КА в предыдущих группах) нацело
на кол-во спутников внутри данной группы.
Полученные значения сравнивались между собой чтобы понять, в одной плоскости, в соседних, или в более отдаленных друг от друга
плоскостях находятся КА.

Затем мною предложен перерасчет индексов имеющих место сеансов связи, дабы хранить самые ближайшие по расстоянию связности.

Возвращает функция две матрицы -- матрицу CsMatrix, которая является требуемой по условию матрицей NxN с 1 или 0 в каждой клетке.
Вторая -- матрица CsMatrixEpoches -  в ней содержится схожая информация, но также с времеными метками.
Это необходимо для того чтобы маршрутизацию в пункте б привязать к времени. Такой подход будет более подходящим для
космической группировки, т.к. не всегда мы сможем дойти из пункта А в пункт Б, у нас может кардинально поменятся топология
сети и передачу осуществить будет невозможно.

В функции getGroupRouteWithMinHops я постарался реализовать алгоритм посика оптимального пути Дейкстры с поправкой на временные метки.

Я модифицровал файл "Constellation Example.py" чтобы включить в него новые функции.
